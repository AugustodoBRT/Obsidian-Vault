![[tp01.pdf]]


#### possivel solução:

```MIPS

# Descrição: Solução CORRIGIDA para o problema "Tiro ao Alvo" (TP01 AOCI).
# O código lê o número de círculos e tiros, os raios dos círculos,
# as coordenadas de cada tiro, e calcula a pontuação total.

# Convenção de Registradores:
# $s1: C (número de círculos)
# $s2: T (número de tiros)
# $s4: Pontuação total (acumulador)
# $gp: Usado como ponteiro base para o array de raios

.text
.globl main

main:
    # --- 1. Leitura de C e T ---
    li   $v0, 5              # syscall para ler inteiro (C)
    syscall
    move $s1, $v0            # Salva C em $s1

    li   $v0, 5              # syscall para ler inteiro (T)
    syscall
    move $s2, $v0            # Salva T em $s2

    # --- 2. Leitura dos Raios ---
    jal  LerRaios            # Chama a sub-rotina para ler os C raios

    # --- 3. Processamento dos Tiros ---
    jal  ProcessarTiros      # Chama a sub-rotina para ler os T tiros e calcular os pontos

    # --- 4. Exibição do Resultado e Fim ---
    j    Exit

#-----------------------------------------------------------------------
# Sub-rotina: LerRaios
# Lê C raios do input e os armazena sequencialmente na memória a partir do endereço em $gp.
# Argumentos: $s1 (C)
# Retorno: Nenhum
#-----------------------------------------------------------------------
LerRaios:
    li   $t0, 0              # Inicializa contador do loop, i = 0
LoopLerRaios:
    beq  $t0, $s1, FimLerRaios # Se i == C, termina o loop

    # Calcula o endereço para salvar o raio: $gp + i * 4
    mul  $t1, $t0, 4
    add  $t1, $t1, $gp

    li   $v0, 5              # Lê o raio Ri
    syscall
    sw   $v0, 0($t1)         # Salva o raio na memória: Mem[gp + i*4] = Ri

    addi $t0, $t0, 1         # i++
    j    LoopLerRaios
FimLerRaios:
    jr   $ra                 # Retorna para a chamada principal

#-----------------------------------------------------------------------
# Sub-rotina: ProcessarTiros
# Loop que executa T vezes, lendo as coordenadas de cada tiro e chamando
# a rotina de cálculo de pontos.
# Argumentos: $s2 (T)
# Retorno: Nenhum
#-----------------------------------------------------------------------
ProcessarTiros:
    li   $t0, 0              # Inicializa contador do loop, i = 0
    li   $s4, 0              # ZERA a pontuação total antes de começar
LoopProcessarTiros:
    beq  $t0, $s2, FimProcessarTiros # Se i == T, termina o loop

    # Lê as coordenadas X e Y do tiro
    li   $v0, 5
    syscall
    move $a0, $v0            # $a0 = Coordenada X

    li   $v0, 5
    syscall
    move $a1, $v0            # $a1 = Coordenada Y

    # Salva o endereço de retorno ($ra) na pilha antes de chamar outra sub-rotina
    addi $sp, $sp, -4
    sw   $ra, 0($sp)

    jal  CalcularPontosDoTiro # Chama a sub-rotina que calcula os pontos para este tiro

    # Restaura o endereço de retorno da pilha
    lw   $ra, 0($sp)
    addi $sp, $sp, 4

    addi $t0, $t0, 1         # i++
    j    LoopProcessarTiros
FimProcessarTiros:
    jr   $ra                 # Retorna para a chamada principal

#-----------------------------------------------------------------------
# Sub-rotina: CalcularPontosDoTiro
# Para um tiro (X,Y), verifica quantos círculos o contêm e atualiza a pontuação total.
# Argumentos: $a0 (X), $a1 (Y), $s1 (C)
# Retorno: Atualiza o registrador global $s4 (pontuação)
#-----------------------------------------------------------------------
CalcularPontosDoTiro:
    # Calcula a distância ao quadrado: Dist^2 = X^2 + Y^2
    mul  $t3, $a0, $a0       # $t3 = X*X
    mul  $t6, $a1, $a1       # $t6 = Y*Y (CORRIGIDO: usar registrador $t6 diferente)
    add  $t3, $t3, $t6       # $t3 = X*X + Y*Y

    # Loop para verificar cada um dos C círculos
    li   $t2, 0              # Inicializa contador do loop de círculos, j = 0
LoopVerificaCirculos:
    beq  $t2, $s1, FimVerificaCirculos # Se j == C, termina o loop

    # Carrega o j-ésimo raio (Rj) da memória
    mul  $t5, $t2, 4
    add  $t5, $t5, $gp
    lw   $t4, 0($t5)         # $t4 = Raio[j]

    # Calcula o raio ao quadrado: Rj^2
    mul  $t4, $t4, $t4       # $t4 = Raio[j] * Raio[j]

    # Condição: O tiro está contido se Dist^2 <= Rj^2
    # Se (X*X + Y*Y) > (Rj*Rj), o ponto está fora. Pula a contagem de ponto.
    bgt  $t3, $t4, ProximoCirculo

    # Se a condição acima for falsa, o ponto está dentro ou na borda. Adiciona 1 ponto.
    addi $s4, $s4, 1

ProximoCirculo:
    addi $t2, $t2, 1         # j++
    j    LoopVerificaCirculos
FimVerificaCirculos:
    jr   $ra                 # Retorna para ProcessarTiros

#-----------------------------------------------------------------------
# Seção de Finalização
#-----------------------------------------------------------------------
Exit:
    # Imprime a pontuação final
    li   $v0, 1
    move $a0, $s4
    syscall

    # Termina o programa
    li   $v0, 10
    syscall
    ```
    